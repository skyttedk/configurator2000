<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>json-tree Web Component</title>
  <style>
    :root { --jt-bg: #0b0f14; --jt-fg: #e6edf3; --jt-muted:#8b949e; --jt-key:#79c0ff; --jt-string:#a5d6ff; --jt-number:#ffd580; --jt-boolean:#ffb4a3; --jt-null:#d2a8ff; --jt-border:#1f2a36; --jt-accent:#58a6ff; --jt-match:#2a4d77; --jt-hover:#151b23; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: var(--jt-bg); color: var(--jt-fg); }
    .demo { max-width: 1100px; margin: 24px auto; padding: 24px; }
    .card { background: #0e141b; border: 1px solid var(--jt-border); border-radius: 16px; padding: 16px; box-shadow: 0 8px 30px rgba(0,0,0,.25); }
    .row { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }
    button { background: #111927; color: var(--jt-fg); border: 1px solid var(--jt-border); padding: 8px 12px; border-radius: 12px; cursor: pointer; font-weight: 600; }
    button:hover { background: var(--jt-hover); }
    input[type="text"] { background: #0b1220; color: var(--jt-fg); border: 1px solid var(--jt-border); padding: 8px 12px; border-radius: 12px; min-width: 260px; }
    .pill { font-size: 12px; color: var(--jt-muted); }
  </style>
</head>
<body>
  <div class="demo">
    <h1>Interactive JSON Tree (Web Component)</h1>
    <p class="pill">Lightweight, framework‑agnostic, instant updates when you set <code>element.data = yourJson</code>.</p>

    <div class="card" style="margin-top:12px">
      <div class="row" style="margin-bottom:12px">
        <button id="btnReplace">Replace data</button>
        <button id="btnMutate">Mutate deeply</button>
        <button id="btnExpandAll">Expand all</button>
        <button id="btnCollapseAll">Collapse all</button>
        <input id="search" type="text" placeholder="Search keys/values… (RegExp supported)" />
      </div>
      <json-tree id="tree" expand-level="1"></json-tree>
    </div>

    <p class="pill">Tip: Click a key to toggle. Alt‑click toggles the whole subtree. Shift‑click copies the JSONPath to clipboard.</p>
  </div>

  <script>
    class JsonTree extends HTMLElement {
      static get observedAttributes() { return ["expand-level"]; }
      constructor() {
        super();
        this.attachShadow({ mode: "open" });
        this._data = undefined;
        this._expandLevel = 1;
        this._expanded = new Set();
        this._searchRe = null;

        const style = document.createElement('style');
        style.textContent = `
          :host { --indent: 16px; display:block; font: 13px/1.5 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace; }
          .tree { border: 1px solid var(--jt-border); border-radius: 12px; overflow: hidden; }
          .row { display:flex; align-items:flex-start; gap:6px; padding:6px 10px; border-top: 1px solid var(--jt-border); }
          .row:first-child{ border-top:none; }
          .row:hover{ background: var(--jt-hover); }
          .twisty { width: 14px; user-select:none; cursor:pointer; opacity:.8; }
          .twisty.hidden { visibility:hidden; }
          .key { color: var(--jt-key); cursor: pointer; }
          .type { color: var(--jt-muted); margin-left: 6px; }
          .value.string { color: var(--jt-string); white-space: pre-wrap; }
          .value.number { color: var(--jt-number); }
          .value.boolean { color: var(--jt-boolean); }
          .value.null { color: var(--jt-null); }
          .children { margin-left: var(--indent); }
          .badge { font-size: 10px; padding:2px 6px; border:1px solid var(--jt-border); border-radius:999px; color: var(--jt-muted); }
          .match { background: var(--jt-match); border-radius: 6px; padding: 1px 2px; }
          .toolbar { display:flex; gap:10px; padding:8px 10px; border-bottom:1px solid var(--jt-border); background:#0c131d; position:sticky; top:-1px; z-index:1; }
        `;
        this._container = document.createElement('div');
        this._container.className = 'tree';
        this.shadowRoot.append(style, this._container);
      }

      get data(){ return this._data; }
      set data(v){
        this._data = v;
        // reset expansion if structure changed drastically (simple heuristic)
        this._expanded = new Set();
        this.render();
      }

      get expandLevel(){ return this._expandLevel; }
      set expandLevel(v){ this._expandLevel = Number(v) || 0; this.render(); }

      attributeChangedCallback(name, oldVal, newVal){
        if(name === 'expand-level' && oldVal !== newVal){ this.expandLevel = newVal; }
      }

      setSearch(pattern){
        try {
          this._searchRe = pattern ? new RegExp(pattern, 'i') : null;
        } catch(e){
          // Treat as literal string if invalid regex
          const esc = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          this._searchRe = esc ? new RegExp(esc, 'i') : null;
        }
        this.render();
      }

      expandAll(){ this._walk((path, node, isBranch)=>{ if(isBranch) this._expanded.add(path); }); this.render(); }
      collapseAll(){ this._expanded.clear(); this.render(); }

      connectedCallback(){ if(this._data === undefined){ this.render(); } }

      render(){
        this._container.innerHTML = '';
        const frag = document.createDocumentFragment();
        const toolbar = document.createElement('div');
        toolbar.className = 'toolbar';
        const left = document.createElement('div'); left.style.flex = '1'; left.textContent = '';
        const right = document.createElement('div'); right.innerHTML = `<span class="badge">${this._countNodes(this._data)} nodes</span>`;
        toolbar.append(left, right);
        frag.append(toolbar);

        const visited = new WeakSet();
        const root = this._renderNode(this._data, '$', 0, visited, null);
        frag.append(root);
        this._container.append(frag);
      }

      _renderNode(value, path, depth, visited, keyLabel){
        const isObject = v => v && typeof v === 'object';
        const row = document.createElement('div');
        row.className = 'row';
        row.style.paddingLeft = depth === 0 ? '10px' : '';

        const twisty = document.createElement('span');
        twisty.className = 'twisty';
        twisty.textContent = '▸';

        const key = document.createElement('span');
        key.className = 'key';
        key.textContent = keyLabel ?? '$';

        const type = document.createElement('span');
        type.className = 'type';

        const valueSpan = document.createElement('span');
        valueSpan.className = 'value';

        const childrenWrap = document.createElement('div');
        childrenWrap.className = 'children';

        const isBranch = Array.isArray(value) || (isObject(value) && value !== null);
        const lengthInfo = Array.isArray(value) ? `Array(${value.length})` : isObject(value) && value !== null ? `Object(${Object.keys(value).length})` : null;

        // Search matching
        const matches = (txt) => this._searchRe ? this._searchRe.test(String(txt)) : false;
        const applyHighlight = (el) => {
          if(!this._searchRe) return;
          const txt = el.textContent;
          const parts = txt.split(this._searchRe);
          if(parts.length === 1) return;
          el.innerHTML = '';
          let lastIndex = 0; let m;
          this._searchRe.lastIndex = 0;
          while((m = this._searchRe.exec(txt))){
            el.append(document.createTextNode(txt.slice(lastIndex, m.index)));
            const span = document.createElement('span'); span.className = 'match'; span.textContent = m[0];
            el.append(span);
            lastIndex = m.index + m[0].length;
          }
          el.append(document.createTextNode(txt.slice(lastIndex)));
        };

        if(isBranch){
          type.textContent = lengthInfo;
          valueSpan.classList.add('null');
          twisty.classList.toggle('hidden', false);
        } else {
          twisty.classList.add('hidden');
          const t = (value === null) ? 'null' : typeof value;
          valueSpan.classList.add(t);
          valueSpan.textContent = this._formatValue(value);
        }

        // auto expand by level or search
        const autoExpand = depth < this._expandLevel || (this._searchRe && (matches(key.textContent) || matches(value))) ;
        const expanded = this._expanded.has(path) || autoExpand;
        if(expanded && isBranch) twisty.textContent = '▾';

        // Toggle logic
        key.addEventListener('click', (ev)=>{
          if(ev.shiftKey){
            navigator.clipboard?.writeText(this._toJsonPath(path)).catch(()=>{});
            key.style.outline = '1px dashed var(--jt-border)';
            setTimeout(()=> key.style.outline = '', 400);
            return;
          }
          if(ev.altKey){
            // toggle entire subtree
            const action = this._expanded.has(path) ? 'collapse' : 'expand';
            this._walk((p, n, isB)=>{ if(p.startsWith(path) && isB){ action==='expand'? this._expanded.add(p): this._expanded.delete(p); } });
            this.render();
            return;
          }
          if(isBranch){
            if(this._expanded.has(path)) this._expanded.delete(path); else this._expanded.add(path);
            this.render();
          }
        });

        // Build children if needed
        if(isBranch && (expanded)){
          if(visited.has(value)){
            const circular = document.createElement('div');
            circular.className = 'children';
            circular.textContent = '[Circular]';
            childrenWrap.append(circular);
          } else {
            visited.add(value);
            const entries = Array.isArray(value) ? value.map((v,i)=>[String(i), v]) : Object.entries(value);
            for(const [k, v] of entries){
              const childPath = path + (Array.isArray(value)?`[${k}]`:`.${this._escapeKey(k)}`);
              childrenWrap.append( this._renderNode(v, childPath, depth+1, visited, k) );
            }
          }
        } else if(isBranch){
          // keep empty children container for spacing when collapsed
          childrenWrap.style.display = 'none';
        }

        // Search highlighting
        if(this._searchRe){
          if(matches(key.textContent)) applyHighlight(key);
          if(!isBranch && matches(valueSpan.textContent)) applyHighlight(valueSpan);
        }

        row.append(twisty, key, type, valueSpan);
        const wrapper = document.createElement('div');
        wrapper.append(row, childrenWrap);
        return wrapper;
      }

      _walk(visitor){
        const visit = (node, path)=>{
          const isBranch = Array.isArray(node) || (node && typeof node === 'object');
          visitor(path, node, isBranch);
          if(isBranch){
            const entries = Array.isArray(node) ? node : Object.values(node);
            entries.forEach((v, i)=>{
              const childPath = path + (Array.isArray(node)?`[${i}]`:`.*`);
              visit(v, childPath);
            });
          }
        };
        visit(this._data, '$');
      }

      _formatValue(v){
        if(v === null) return 'null';
        if(typeof v === 'string'){
          if(v.length > 240) return JSON.stringify(v.slice(0,240) + '…');
          return JSON.stringify(v);
        }
        if(typeof v === 'number' || typeof v === 'boolean') return String(v);
        if(v instanceof Date) return `Date(${v.toISOString()})`;
        if(typeof v === 'undefined') return 'undefined';
        try { return JSON.stringify(v); } catch { return String(v); }
      }

      _escapeKey(k){ return k.replace(/[^A-Za-z0-9_]/g, (m)=>`['${m}']`); }
      _toJsonPath(path){ return path; }
      _countNodes(node){
        const visited = new WeakSet();
        let count = 0;
        const walk = (n)=>{
          count++;
          if(n && typeof n === 'object'){
            if(visited.has(n)) return; visited.add(n);
            const vals = Array.isArray(n) ? n : Object.values(n);
            for(const v of vals) walk(v);
          }
        };
        try{ walk(node); } catch {}
        return count;
      }
    }

    customElements.define('json-tree', JsonTree);

    // --- Demo wiring ---
    const jt = document.getElementById('tree');
    const sample = {
      id: 42,
      name: 'Launch sequence',
      ok: true,
      tags: ['alpha','beta','gamma'],
      meta: { owner: 'sigurd', ts: new Date().toISOString(), note: 'Click keys to expand/collapse' },
      nested: { a: { b: { c: { d: { e: 1 } } } } },
      text: 'This is a long string that will wrap. You can search for words using the input above.',
    };
    sample.self = sample; // circular for demo

    jt.data = sample;

    document.getElementById('btnReplace').onclick = ()=>{
      jt.data = { replaced: true, when: new Date().toISOString(), items: Array.from({length:5}, (_,i)=>({ i, rnd: Math.random() })) };
    };
    document.getElementById('btnMutate').onclick = ()=>{
      // Mutate deeply and reassign to trigger immediate re-render
      const copy = JSON.parse(JSON.stringify(jt.data, (k,v)=> (v === jt.data ? undefined : v))); // drop circular if present
      if(!copy.deep) copy.deep = { level: 0 };
      copy.deep.level++;
      copy.deep.timestamp = new Date().toISOString();
      jt.data = copy;
    };
    document.getElementById('btnExpandAll').onclick = ()=> jt.expandAll();
    document.getElementById('btnCollapseAll').onclick = ()=> jt.collapseAll();
    document.getElementById('search').addEventListener('input', (e)=> jt.setSearch(e.target.value));
  </script>
</body>
</html>