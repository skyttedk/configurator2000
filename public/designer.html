<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Form Designer - Configurator2000</title>
  
  <!-- React and dependencies -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- React JSON Schema Form - Stable version -->
  <script src="https://unpkg.com/react-jsonschema-form@1.8.1/dist/react-jsonschema-form.js"></script>
  
  <!-- Bootstrap for styling -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  
  <style>
    body { font-family: Arial, sans-serif; background: #f8f9fa; }
    .container-fluid { padding: 20px; }
    .schema-input { width: 100%; height: 300px; font-family: monospace; font-size: 12px; }
    .ai-section { background: #e7f3ff; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #007bff; }
    .rules-section { background: #fff3e0; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ff9800; }
    .json-viewer { background: #f8f9fa; padding: 15px; border-radius: 8px; white-space: pre; font-family: monospace; border: 1px solid #dee2e6; max-height: 400px; overflow: auto; }
    .error { color: red; background: #ffe6e6; padding: 10px; border-radius: 5px; margin: 10px 0; }
    .form-section { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .btn-ai { background: #28a745; border-color: #28a745; }
    .btn-ai:hover { background: #218838; border-color: #218838; }
    .btn-rules { background: #ff9800; border-color: #ff9800; color: white; }
    .btn-rules:hover { background: #f57c00; border-color: #f57c00; color: white; }
    .rule-item { background: white; border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin: 5px 0; display: flex; justify-content: space-between; align-items: center; }
    .rule-text { flex: 1; margin-right: 10px; }
    .rule-actions { display: flex; gap: 5px; }
    .rule-input { border: none; background: transparent; width: 100%; }
    .rule-input:focus { outline: 1px solid #007bff; background: #f8f9fa; }
    .rules-list { max-height: 300px; overflow-y: auto; }
    
    /* Toast Notifications */
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
    }
    .toast {
      background: #333;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      margin-bottom: 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      min-width: 300px;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
    }
    .toast.show {
      opacity: 1;
      transform: translateX(0);
    }
    .toast.success { background: #28a745; }
    .toast.info { background: #17a2b8; }
    .toast.warning { background: #ffc107; color: #000; }
    .toast.danger { background: #dc3545; }
    .toast .icon { margin-right: 10px; font-size: 18px; }
  </style>
</head>
<body>
  <div class="container-fluid">
    <div class="row">
      <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
          <div>
            <h1>Form Designer</h1>
            <div id="configNameDisplay" class="text-muted"></div>
          </div>
          <a href="admin.html" class="btn btn-outline-secondary">‚Üê Back to Admin</a>
        </div>
      </div>
    </div>

    <div class="row">
      <!-- Left Column: Data & Schemas -->
      <div class="col-lg-6">
        <div class="form-section mb-4">
          <h3>Schema Configuration</h3>
          
          <div class="mb-3">
            <label class="form-label">JSON Schema</label>
            <textarea id="jsonSchema" class="form-control schema-input" placeholder="Enter JSON Schema..."></textarea>
          </div>
          
          <div class="mb-3">
            <label class="form-label">UI Schema</label>
            <textarea id="uiSchema" class="form-control schema-input" placeholder="Enter UI Schema..."></textarea>
          </div>
          
          <div class="mb-3">
            <label class="form-label">Form Data</label>
            <textarea id="formData" class="form-control schema-input" placeholder="Enter Form Data..."></textarea>
          </div>

          <div class="mb-3">
            <label class="form-label">JavaScript Functions <small class="text-muted">(Generated by AI for complex rules)</small></label>
            <textarea id="jsFunctions" class="form-control schema-input" placeholder="Generated JavaScript functions will appear here..." style="height: 200px;"></textarea>
          </div>
          
        </div>

        <!-- Rules Section -->
        <div class="rules-section">
          <h4>üìã Rules List</h4>
          <div class="mb-3">
            <input type="text" id="newRuleInput" class="form-control" placeholder="Enter new rule..." />
          </div>
          <button id="addRuleButton" class="btn btn-rules btn-sm">Add Rule</button>
          <button id="applyRulesButton" class="btn btn-outline-warning btn-sm ms-2">Apply All Rules</button>
          <div id="rulesList" class="rules-list mt-3"></div>
        </div>
      </div>

      <!-- Right Column: Form & AI -->
      <div class="col-lg-6">
        <!-- Generated Form Section -->
        <div class="form-section mb-4">
          <h3>Generated Form</h3>
          <div id="formContainer"></div>
        </div>

        <!-- AI Assistant Section -->
        <div class="ai-section">
          <h4>ü§ñ Claude AI Assistant</h4>
          <div class="mb-3">
            <input type="text" id="commandInput" class="form-control" placeholder="Enter command (e.g., 'add age field', 'make firstName required', 'set default values')..." />
          </div>
          <div class="d-flex gap-2">
            <button id="aiButton" class="btn btn-ai">Modify All Schemas with AI</button>
            <button id="saveButton" class="btn btn-success">üíæ Save to Database</button>
          </div>
          <div class="mt-2">
            <small class="text-muted">
              üéØ AI will automatically update all schemas (JSON, UI, Data)<br>
              üìã <span id="rulesCount">3 rules</span> will be enforced
            </small>
          </div>
        </div>
        
        <div id="error"></div>
      </div>
    </div>
  </div>

  <!-- Toast Container -->
  <div class="toast-container" id="toastContainer"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;
    
    // Use JSONSchemaForm with proper handling
    console.log('Available:', window.JSONSchemaForm);
    const Form = window.JSONSchemaForm.default || window.JSONSchemaForm;

    // Global variables for loaded configuration (accessible from both React and plain JS)
    window.loadedConfiguration = null;
    window.configurationId = null;

    // Get configuration ID from URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    window.configurationId = urlParams.get('id');
    
    // Create shorter references for convenience
    let loadedConfiguration = window.loadedConfiguration;
    let configurationId = window.configurationId;

    // Default empty schemas (used if no configuration is loaded)
    const defaultSchema = {};
    const defaultUiSchema = {};
    const defaultFormData = {};

    // Function to load configuration from database
    async function loadConfiguration(id) {
      try {
        const response = await fetch(`/api/configurations/${id}`);
        if (!response.ok) throw new Error('Failed to load configuration');
        
        const config = await response.json();
        window.loadedConfiguration = config;
        loadedConfiguration = config;
        
        // Parse AI-generated schemas if they exist
        const parsedDataSchema = config.data_schema ? JSON.parse(config.data_schema) : {};
        const parsedUiSchema = config.ui_schema ? JSON.parse(config.ui_schema) : {};
        const parsedFormData = {}; // Start with empty form data
        
        return {
          schema: parsedDataSchema,
          uiSchema: parsedUiSchema,
          formData: parsedFormData
        };
      } catch (error) {
        console.error('Error loading configuration:', error);
        return {
          schema: defaultSchema,
          uiSchema: defaultUiSchema,
          formData: defaultFormData
        };
      }
    }

    function App() {
      const [schema, setSchema] = useState(defaultSchema);
      const [uiSchema, setUiSchema] = useState(defaultUiSchema);
      const [formData, setFormData] = useState(defaultFormData);
      const [currentFormData, setCurrentFormData] = useState(defaultFormData);
      const [error, setError] = useState('');

      // Initialize textareas with loaded configuration or defaults
      useEffect(() => {
        async function initializeData() {
          let initialData;
          
          if (window.configurationId) {
            initialData = await loadConfiguration(window.configurationId);
            console.log('Loaded configuration:', window.loadedConfiguration);
            
            // Display configuration name
            if (window.loadedConfiguration) {
              document.getElementById('configNameDisplay').textContent = 
                `Editing: ${window.loadedConfiguration.name}`;
            }
          } else {
            initialData = {
              schema: defaultSchema,
              uiSchema: defaultUiSchema,
              formData: defaultFormData
            };
          }
          
          document.getElementById('jsonSchema').value = JSON.stringify(initialData.schema, null, 2);
          document.getElementById('uiSchema').value = JSON.stringify(initialData.uiSchema, null, 2);
          document.getElementById('formData').value = JSON.stringify(initialData.formData, null, 2);
          
          setSchema(initialData.schema);
          setUiSchema(initialData.uiSchema);
          setFormData(initialData.formData);
          setCurrentFormData(initialData.formData);
          
          // If this is first time (no saved schemas), automatically generate from semantic schema
          if (window.configurationId && window.loadedConfiguration && 
              (!window.loadedConfiguration.data_schema || window.loadedConfiguration.data_schema.trim() === '')) {
            console.log('First time for this configuration - auto-generating schemas...');
            setTimeout(() => {
              generateInitialSchemas();
            }, 1000);
          }
        }
        
        initializeData();
      }, []);

      const renderForm = () => {
        setError('');
        try {
          const schemaText = document.getElementById('jsonSchema').value.trim();
          const uiSchemaText = document.getElementById('uiSchema').value.trim();
          const formDataText = document.getElementById('formData').value.trim();

          const newSchema = schemaText ? JSON.parse(schemaText) : {};
          const newUiSchema = uiSchemaText ? JSON.parse(uiSchemaText) : {};
          const newFormData = formDataText ? JSON.parse(formDataText) : {};

          console.log('Rendering form with:', { newSchema, newUiSchema, newFormData });

          setSchema(newSchema);
          setUiSchema(newUiSchema);
          setFormData(newFormData);
          setCurrentFormData(newFormData);
        } catch (e) {
          setError(`Invalid JSON: ${e.message}`);
        }
      };

      // Expose renderForm globally so it can be called from outside React
      useEffect(() => {
        window.renderFormFunction = renderForm;
      }, []);

      const handleFormChange = ({ formData }) => {
        setCurrentFormData(formData);
        // Update the Form Data textarea with current form values
        document.getElementById('formData').value = JSON.stringify(formData, null, 2);
        
        // Execute rule functions when form data changes
        if (window.executeAllRuleFunctions) {
          window.executeAllRuleFunctions();
        }
      };

      // handleAI is now handled outside React component

      return (
        <div>
          {error && <div className="error">{error}</div>}
          <Form
            schema={schema}
            uiSchema={uiSchema}
            formData={currentFormData}
            onChange={handleFormChange}
            onSubmit={({formData}) => {
              alert('Form submitted with: ' + JSON.stringify(formData, null, 2));
            }}
          />
        </div>
      );
    }

    // Create root and render the React component
    const root = ReactDOM.createRoot(document.getElementById('formContainer'));
    root.render(<App />);

    // Set up event listeners
    document.getElementById('renderButton').addEventListener('click', () => {
      // Trigger re-render by dispatching a custom event
      window.dispatchEvent(new CustomEvent('renderForm'));
    });

    // Custom event listener for form rendering
    window.addEventListener('renderForm', () => {
      if (window.renderFormFunction) {
        window.renderFormFunction();
      }
    });

  </script>

  <script>
    // JavaScript Functions Execution System - declare early
    let activeRuleFunctions = {};

    // Toast notification system
    function showToast(message, type = 'info', duration = 4000) {
      const container = document.getElementById('toastContainer');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      
      const icons = {
        success: '‚úÖ',
        info: 'üîÑ',
        warning: '‚ö†Ô∏è',
        danger: '‚ùå'
      };
      
      toast.innerHTML = `
        <span class="icon">${icons[type] || 'üì¢'}</span>
        <span>${message}</span>
      `;
      
      container.appendChild(toast);
      
      // Show toast
      setTimeout(() => toast.classList.add('show'), 100);
      
      // Hide and remove toast
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 300);
      }, duration);
    }

    // Non-React JavaScript for AI functionality
    document.getElementById('aiButton').addEventListener('click', async () => {
      const command = document.getElementById('commandInput').value.trim();
      const target = 'all'; // Always update all schemas
      const errorDiv = document.getElementById('error');
      
      if (!command) {
        errorDiv.innerHTML = '<div class="error">Please enter a command</div>';
        return;
      }

      const aiButton = document.getElementById('aiButton');
      aiButton.disabled = true;
      aiButton.textContent = 'Processing...';
      errorDiv.innerHTML = '';

      try {
        // Get current semantic schema and rules from the loaded configuration
        const currentSemanticSchema = window.loadedConfiguration ? window.loadedConfiguration.semantic_schema : '';
        const currentRuleSet = rules.map(rule => rule.text);
        
        const payload = {
          command,
          target,
          // Current schemas (what user is working with now)
          schema: JSON.parse(document.getElementById('jsonSchema').value || '{}'),
          uiSchema: JSON.parse(document.getElementById('uiSchema').value || '{}'),
          formData: JSON.parse(document.getElementById('formData').value || '{}'),
          rules: currentRuleSet,
          currentFunctions: document.getElementById('jsFunctions').value || '',
          
          // Current user changes that caused this AI call
          currentSemanticSchema: currentSemanticSchema,
          currentRuleSet: currentRuleSet,
          
          // Last saved state from database (for comparison)
          lastSemanticSchema: window.loadedConfiguration ? window.loadedConfiguration.semantic_schema : '',
          lastRuleSet: window.loadedConfiguration ? (window.loadedConfiguration.rules || '').split('\n').filter(r => r.trim()) : [],
          lastDataSchema: window.loadedConfiguration ? (window.loadedConfiguration.data_schema || '{}') : '{}',
          lastUISchema: window.loadedConfiguration ? (window.loadedConfiguration.ui_schema || '{}') : '{}',
          lastJsFunctionImpl: window.loadedConfiguration ? (window.loadedConfiguration.js_function_impl || '') : ''
        };

        const response = await fetch('/api/modify-schemas', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        const result = await response.json();

        if (!response.ok) {
          throw new Error(result.error || 'Failed to modify schemas');
        }

        // Replace with AI response (don't merge to allow deletions)
        // Claude returns complete objects, so we can safely replace
        if (result.schema) {
          document.getElementById('jsonSchema').value = JSON.stringify(result.schema, null, 2);
        }
        if (result.uiSchema) {
          document.getElementById('uiSchema').value = JSON.stringify(result.uiSchema, null, 2);
        }
        if (result.formData) {
          document.getElementById('formData').value = JSON.stringify(result.formData, null, 2);
        }
        if (result.jsFunctions) {
          document.getElementById('jsFunctions').value = result.jsFunctions;
          // Execute/inject the new JavaScript functions
          executeGeneratedFunctions(result.jsFunctions);
        }

        // Trigger form re-render automatically
        if (window.renderFormFunction) {
          window.renderFormFunction();
        }
        document.getElementById('commandInput').value = '';
        
        // Show save button since content has changed
        if (window.configurationId) {
          const saveBtn = document.getElementById('saveButton');
          console.log('Showing save button, element found:', !!saveBtn);
          if (saveBtn) {
            saveBtn.style.display = 'inline-block';
          }
        }

      } catch (error) {
        errorDiv.innerHTML = `<div class="error">${error.message}</div>`;
      } finally {
        aiButton.disabled = false;
        aiButton.textContent = 'Modify with AI';
      }
    });

    // Allow Enter key in command input
    function setupEventListeners() {
      const commandInput = document.getElementById('commandInput');
      const aiButton = document.getElementById('aiButton');
      
      if (commandInput && aiButton) {
        commandInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            aiButton.click();
          }
        });
        console.log('Event listeners set up successfully');
      } else {
        console.error('Could not find required elements:', { commandInput: !!commandInput, aiButton: !!aiButton });
      }
    }
    
    // Set up event listeners when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupEventListeners);
    } else {
      setupEventListeners();
    }

    // Save button functionality
    function setupSaveButton() {
      const saveButton = document.getElementById('saveButton');
      if (!saveButton) {
        console.error('Save button not found in DOM');
        return;
      }
      
      console.log('Setting up save button event listener');
      saveButton.addEventListener('click', async (e) => {
        console.log('Save button clicked!');
        e.preventDefault();
      if (!window.configurationId || !window.loadedConfiguration) {
        showToast('No configuration loaded to save', 'warning');
        return;
      }

      const saveButton = document.getElementById('saveButton');
      saveButton.disabled = true;
      const originalText = saveButton.textContent;
      saveButton.textContent = 'üíæ Saving...';
      
      showToast('Saving schemas to database...', 'info');

      try {
        const updates = {
          dataSchema: document.getElementById('jsonSchema').value.trim(),
          uiSchema: document.getElementById('uiSchema').value.trim(),
          jsFunctionImpl: document.getElementById('jsFunctions').value.trim()
        };

        const response = await fetch(`/api/configurations/${window.configurationId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(updates)
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to save configuration');
        }

        // Update loaded configuration with saved values
        window.loadedConfiguration.data_schema = updates.dataSchema;
        window.loadedConfiguration.ui_schema = updates.uiSchema;
        window.loadedConfiguration.js_function_impl = updates.jsFunctionImpl;

        showToast('Schemas saved successfully!', 'success');
        
        // Hide save button since data is now saved
        saveButton.style.display = 'none';

      } catch (error) {
        console.error('Save error:', error);
        showToast(`Error saving: ${error.message}`, 'danger');
      } finally {
        saveButton.disabled = false;
        saveButton.textContent = originalText;
      }
      });
    }
    
    // Call setup function immediately and also after DOM is ready
    setupSaveButton();
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupSaveButton);
    }

    // Rules Management
    let rules = [];
    let ruleIdCounter = 1;

    // Auto-apply rules with AI
    async function applyRulesWithAI(command) {
      const errorDiv = document.getElementById('error');
      const aiButton = document.getElementById('aiButton');
      
      // Show visual feedback
      const originalText = aiButton.textContent;
      aiButton.textContent = 'Applying rules...';
      aiButton.disabled = true;
      errorDiv.innerHTML = '<div class="alert alert-info">ü§ñ Automatically applying rules to current schemas...</div>';
      
      try {
        // Get current semantic schema and rules from the loaded configuration
        const currentSemanticSchema = window.loadedConfiguration ? window.loadedConfiguration.semantic_schema : '';
        const currentRuleSet = rules.map(rule => rule.text);
        
        const payload = {
          command,
          target: 'all', // Always check all schemas when applying rules
          // Current schemas (what user is working with now)
          schema: JSON.parse(document.getElementById('jsonSchema').value || '{}'),
          uiSchema: JSON.parse(document.getElementById('uiSchema').value || '{}'),
          formData: JSON.parse(document.getElementById('formData').value || '{}'),
          rules: currentRuleSet,
          currentFunctions: document.getElementById('jsFunctions').value || '',
          
          // Current user changes that caused this AI call
          currentSemanticSchema: currentSemanticSchema,
          currentRuleSet: currentRuleSet,
          
          // Last saved state from database (for comparison)
          lastSemanticSchema: window.loadedConfiguration ? window.loadedConfiguration.semantic_schema : '',
          lastRuleSet: window.loadedConfiguration ? (window.loadedConfiguration.rules || '').split('\n').filter(r => r.trim()) : [],
          lastDataSchema: window.loadedConfiguration ? (window.loadedConfiguration.data_schema || '{}') : '{}',
          lastUISchema: window.loadedConfiguration ? (window.loadedConfiguration.ui_schema || '{}') : '{}',
          lastJsFunctionImpl: window.loadedConfiguration ? (window.loadedConfiguration.js_function_impl || '') : ''
        };

        const response = await fetch('/api/modify-schemas', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        const result = await response.json();

        if (!response.ok) {
          throw new Error(result.error || 'Failed to apply rules');
        }

        // Replace with AI response (don't merge to allow deletions)
        // Claude returns complete objects, so we can safely replace
        if (result.schema) {
          document.getElementById('jsonSchema').value = JSON.stringify(result.schema, null, 2);
        }
        if (result.uiSchema) {
          document.getElementById('uiSchema').value = JSON.stringify(result.uiSchema, null, 2);
        }
        if (result.formData) {
          document.getElementById('formData').value = JSON.stringify(result.formData, null, 2);
        }
        if (result.jsFunctions) {
          document.getElementById('jsFunctions').value = result.jsFunctions;
          // Execute/inject the new JavaScript functions
          executeGeneratedFunctions(result.jsFunctions);
        }

        // Trigger form re-render
        if (window.renderFormFunction) {
          window.renderFormFunction();
        }

        // Show success message
        errorDiv.innerHTML = '<div class="alert alert-success">‚úÖ Rules applied successfully!</div>';
        setTimeout(() => errorDiv.innerHTML = '', 3000);

      } catch (error) {
        errorDiv.innerHTML = `<div class="alert alert-danger">‚ùå Error applying rules: ${error.message}</div>`;
      } finally {
        aiButton.textContent = originalText;
        aiButton.disabled = false;
      }
    }

    function renderRulesList() {
      const rulesList = document.getElementById('rulesList');
      rulesList.innerHTML = '';
      
      // Update rules count in AI section
      const rulesCount = document.getElementById('rulesCount');
      if (rulesCount) {
        rulesCount.textContent = rules.length === 0 ? 'No rules' : 
          rules.length === 1 ? '1 rule' : `${rules.length} rules`;
      }
      
      if (rules.length === 0) {
        rulesList.innerHTML = '<div class="text-muted">No rules added yet...</div>';
        return;
      }

      rules.forEach(rule => {
        const ruleElement = document.createElement('div');
        ruleElement.className = 'rule-item';
        ruleElement.innerHTML = `
          <div class="rule-text">
            <input type="text" class="rule-input" value="${rule.text}" data-rule-id="${rule.id}" />
          </div>
          <div class="rule-actions">
            <button class="btn btn-outline-primary btn-sm save-rule" data-rule-id="${rule.id}" title="Save">üíæ</button>
            <button class="btn btn-outline-danger btn-sm delete-rule" data-rule-id="${rule.id}" title="Delete">üóëÔ∏è</button>
          </div>
        `;
        rulesList.appendChild(ruleElement);
      });
    }

    async function addRule() {
      const input = document.getElementById('newRuleInput');
      const ruleText = input.value.trim();
      
      if (ruleText) {
        rules.push({
          id: ruleIdCounter++,
          text: ruleText
        });
        input.value = '';
        renderRulesList();
        
        // Auto-trigger AI to apply new rule to current schemas
        await applyRulesWithAI(`Apply this new rule: "${ruleText}"`);
      }
    }

    async function saveRule(ruleId) {
      const input = document.querySelector(`input[data-rule-id="${ruleId}"]`);
      const rule = rules.find(r => r.id == ruleId);
      if (rule && input) {
        const oldRuleText = rule.text;
        const newRuleText = input.value.trim();
        
        if (newRuleText === '') {
          deleteRule(ruleId);
        } else {
          rule.text = newRuleText;
          renderRulesList();
          
          // Auto-trigger AI if rule text changed
          if (oldRuleText !== newRuleText) {
            await applyRulesWithAI(`Rule updated from "${oldRuleText}" to "${newRuleText}". Apply all current rules.`);
          }
        }
      }
    }

    function deleteRule(ruleId) {
      rules = rules.filter(r => r.id != ruleId);
      renderRulesList();
    }

    // Event listeners for rules
    document.getElementById('addRuleButton').addEventListener('click', addRule);
    
    document.getElementById('applyRulesButton').addEventListener('click', async () => {
      await applyRulesWithAI('Review and apply all current rules to ensure compliance across all schemas and form data.');
    });
    
    document.getElementById('newRuleInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        addRule();
      }
    });

    document.getElementById('rulesList').addEventListener('click', async (e) => {
      if (e.target.classList.contains('save-rule')) {
        const ruleId = e.target.getAttribute('data-rule-id');
        await saveRule(ruleId);
      } else if (e.target.classList.contains('delete-rule')) {
        const ruleId = e.target.getAttribute('data-rule-id');
        deleteRule(ruleId);
      }
    });

    document.getElementById('rulesList').addEventListener('keypress', async (e) => {
      if (e.key === 'Enter' && e.target.classList.contains('rule-input')) {
        const ruleId = e.target.getAttribute('data-rule-id');
        await saveRule(ruleId);
      }
    });

    // JavaScript Functions Execution System
    function executeGeneratedFunctions(functionsCode) {
      try {
        // Clear existing functions
        activeRuleFunctions = {};
        
        // Create a comprehensive update function for the generated code
        function updateForm(newSchema, newUiSchema, newFormData) {
          if (newSchema) {
            document.getElementById('jsonSchema').value = JSON.stringify(newSchema, null, 2);
          }
          if (newUiSchema) {
            document.getElementById('uiSchema').value = JSON.stringify(newUiSchema, null, 2);
          }
          if (newFormData) {
            document.getElementById('formData').value = JSON.stringify(newFormData, null, 2);
          }
          // Re-render the form
          if (window.renderFormFunction) {
            window.renderFormFunction();
          }
        }
        
        // Execute the functions code to define them globally
        const func = new Function('updateForm', `
          ${functionsCode}
          
          // Return all functions that start with 'applyRule'
          const ruleFunctions = {};
          if (typeof applyRule1 !== 'undefined') ruleFunctions.applyRule1 = applyRule1;
          if (typeof applyRule2 !== 'undefined') ruleFunctions.applyRule2 = applyRule2;
          if (typeof applyRule3 !== 'undefined') ruleFunctions.applyRule3 = applyRule3;
          if (typeof applyRule4 !== 'undefined') ruleFunctions.applyRule4 = applyRule4;
          if (typeof applyRule5 !== 'undefined') ruleFunctions.applyRule5 = applyRule5;
          
          return ruleFunctions;
        `);
        
        activeRuleFunctions = func(updateForm) || {};
        
        console.log('Generated rule functions:', Object.keys(activeRuleFunctions));
        console.log('Functions code:', functionsCode);
        
        // Execute all rule functions immediately to check current state
        setTimeout(() => {
          try {
            executeAllRuleFunctions();
          } catch (error) {
            console.error('Error executing rule functions on load:', error);
          }
        }, 100);
        
      } catch (error) {
        console.error('Error executing generated functions:', error);
        document.getElementById('error').innerHTML = `<div class="alert alert-danger">‚ùå Error in generated JavaScript: ${error.message}</div>`;
      }
    }

    function updateSchemaFromFunction(newSchema) {
      document.getElementById('jsonSchema').value = JSON.stringify(newSchema, null, 2);
      window.renderFormFunction && window.renderFormFunction();
    }

    function updateFormDataFromFunction(newFormData) {
      document.getElementById('formData').value = JSON.stringify(newFormData, null, 2);
      window.renderFormFunction && window.renderFormFunction();
    }

    function executeAllRuleFunctions() {
      // Guard against early execution
      if (typeof activeRuleFunctions === 'undefined') {
        console.warn('activeRuleFunctions not initialized yet');
        return;
      }
      
      try {
        const currentFormData = JSON.parse(document.getElementById('formData').value || '{}');
        const currentSchema = JSON.parse(document.getElementById('jsonSchema').value || '{}');
        const currentUiSchema = JSON.parse(document.getElementById('uiSchema').value || '{}');
      
      // Create the updateForm function that Claude's functions expect
      function updateForm(newSchema, newUiSchema, newFormData) {
        console.log('updateForm called with:', { newSchema: !!newSchema, newUiSchema: !!newUiSchema, newFormData: !!newFormData });
        
        if (newSchema) {
          document.getElementById('jsonSchema').value = JSON.stringify(newSchema, null, 2);
          console.log('Updated schema, bio field present:', !!newSchema.properties?.bio);
        }
        if (newUiSchema) {
          document.getElementById('uiSchema').value = JSON.stringify(newUiSchema, null, 2);
          console.log('Updated uiSchema, bio field present:', !!newUiSchema.bio);
        }
        if (newFormData) {
          document.getElementById('formData').value = JSON.stringify(newFormData, null, 2);
          console.log('Updated formData, bio field present:', !!newFormData.bio);
        }
        
        // Force re-render the form with a slight delay to ensure state updates
        setTimeout(() => {
          if (window.renderFormFunction) {
            console.log('Forcing form re-render...');
            window.renderFormFunction();
          }
        }, 100);
      }
      
      for (const [funcName, func] of Object.entries(activeRuleFunctions)) {
        try {
          console.log(`Executing ${funcName} with age:`, currentFormData.age);
          func(currentFormData, currentSchema, currentUiSchema, updateForm);
        } catch (error) {
          console.error(`Error executing rule function ${funcName}:`, error);
        }
      }
      } catch (error) {
        console.error('Error in executeAllRuleFunctions:', error);
      }
    }

    // Expose function globally
    window.executeAllRuleFunctions = executeAllRuleFunctions;

    // Initialize with empty rules - load from configuration if available
    rules = [];
    function initializeRulesFromConfig() {
      if (window.loadedConfiguration && window.loadedConfiguration.rules) {
        const configRules = window.loadedConfiguration.rules.split('\n').filter(r => r.trim());
        configRules.forEach(rule => {
          rules.push({ id: ruleIdCounter++, text: rule.trim() });
        });
        renderRulesList();
      } else {
        renderRulesList();
      }
    }
    
    // Call immediately and also after a delay to ensure config is loaded
    initializeRulesFromConfig();
    setTimeout(initializeRulesFromConfig, 1000);

    // Function to generate initial schemas from semantic schema (first time only)
    async function generateInitialSchemas() {
      if (!window.loadedConfiguration || !window.loadedConfiguration.semantic_schema) {
        console.log('No semantic schema available for initial generation');
        return;
      }
      
      showToast('Generating initial schemas from semantic description...', 'info', 6000);
      
      try {
        // Get current semantic schema and rules from the loaded configuration
        const currentSemanticSchema = window.loadedConfiguration.semantic_schema;
        const currentRuleSet = window.loadedConfiguration.rules ? 
          window.loadedConfiguration.rules.split('\n').filter(r => r.trim()) : [];
        
        const payload = {
          command: `Generate complete form schemas based on the semantic description: "${currentSemanticSchema}". Create appropriate JSON schema, UI schema, form data, and any needed JavaScript functions.`,
          target: 'all',
          // Current schemas (empty for first time)
          schema: {},
          uiSchema: {},
          formData: {},
          rules: currentRuleSet,
          currentFunctions: '',
          
          // Current user input (semantic schema and rules)
          currentSemanticSchema: currentSemanticSchema,
          currentRuleSet: currentRuleSet,
          
          // Last saved state (empty for first time)
          lastSemanticSchema: '',
          lastRuleSet: [],
          lastDataSchema: '{}',
          lastUISchema: '{}',
          lastJsFunctionImpl: ''
        };

        const response = await fetch('/api/modify-schemas', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        const result = await response.json();

        if (!response.ok) {
          throw new Error(result.error || 'Failed to generate initial schemas');
        }

        // Update the textareas with generated content
        if (result.schema) {
          document.getElementById('jsonSchema').value = JSON.stringify(result.schema, null, 2);
        }
        if (result.uiSchema) {
          document.getElementById('uiSchema').value = JSON.stringify(result.uiSchema, null, 2);
        }
        if (result.formData) {
          document.getElementById('formData').value = JSON.stringify(result.formData, null, 2);
        }
        if (result.jsFunctions) {
          document.getElementById('jsFunctions').value = result.jsFunctions;
          executeGeneratedFunctions(result.jsFunctions);
        }

        // Trigger form re-render
        if (window.renderFormFunction) {
          window.renderFormFunction();
        }

        showToast('Initial schemas generated successfully!', 'success');
        
        // Show save button since content was generated
        if (window.configurationId) {
          const saveBtn = document.getElementById('saveButton');
          console.log('Showing save button after initial generation, element found:', !!saveBtn);
          if (saveBtn) {
            saveBtn.style.display = 'inline-block';
          }
        }

      } catch (error) {
        console.error('Error generating initial schemas:', error);
        showToast(`Error generating initial schemas: ${error.message}`, 'danger');
      }
    }
  </script>
</body>
</html>
